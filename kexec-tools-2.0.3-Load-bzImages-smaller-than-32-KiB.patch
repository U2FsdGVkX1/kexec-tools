From 0e4946bc3009e7b9ce6f9d792077eddd7e40cc14 Mon Sep 17 00:00:00 2001
From: Eric Biggers <ebiggers3@gmail.com>
Date: Tue, 5 Jun 2012 19:46:07 -0400
Subject: [PATCH] Load bzImages smaller than 32 KiB

Allow bzImages smaller than 32KiB to be kexec'ed.

The current code will fail to load a bzImage smaller than 32768 bytes (sizeof
struct x86_linux_header), but the 'memdisk' program that comes with syslinux is
only about 26 KiB.  This patch changes the minimum size to 1024 bytes (2
sectors), which appears to be the limit that syslinux enforces.

Removed the "tail" field of struct x86_linux_header because it doesn't seem to
actually be used (is there a reason for it?).

Also, note that bzImage_probe() was incorrectly using `sizeof (header)', even
though header is a pointer.

Signed-off-by: Eric Biggers <ebiggers3@gmail.com>
Signed-off-by: Simon Horman <horms@verge.net.au>
---
 include/x86/x86-linux.h         |    2 --
 kexec/arch/i386/kexec-bzImage.c |    7 +++++--
 2 files changed, 5 insertions(+), 4 deletions(-)

diff --git a/include/x86/x86-linux.h b/include/x86/x86-linux.h
index 59d35c9..2ebcc3a 100644
--- a/include/x86/x86-linux.h
+++ b/include/x86/x86-linux.h
@@ -233,7 +233,6 @@ struct x86_linux_header {
 	uint32_t high_base;			/* 0x24C */
 	uint32_t high_memsz;			/* 0x250 */
 	uint32_t high_filesz;			/* 0x254 */
-	uint32_t tail[32*1024 - 0x258];		/* 0x258 */
 #else
 	uint32_t kernel_alignment;		/* 0x230 */
 	uint8_t  relocatable_kernel;		/* 0x234 */
@@ -241,7 +240,6 @@ struct x86_linux_header {
 	uint32_t cmdline_size;                  /* 0x238 */
 	uint32_t hardware_subarch;              /* 0x23C */
 	uint64_t hardware_subarch_data;         /* 0x240 */
-	uint8_t  tail[32*1024 - 0x248];		/* 0x248 */
 #endif
 } PACKED;
 
diff --git a/kexec/arch/i386/kexec-bzImage.c b/kexec/arch/i386/kexec-bzImage.c
index 54c4427..6998587 100644
--- a/kexec/arch/i386/kexec-bzImage.c
+++ b/kexec/arch/i386/kexec-bzImage.c
@@ -44,7 +44,10 @@ static const int probe_debug = 0;
 int bzImage_probe(const char *buf, off_t len)
 {
 	const struct x86_linux_header *header;
-	if ((uintmax_t)len < (uintmax_t)sizeof(header)) {
+	if ((uintmax_t)len < (uintmax_t)(2 * 512)) {
+		if (probe_debug) {
+			fprintf(stderr, "File is too short to be a bzImage!\n");
+		}
 		return -1;
 	}
 	header = (const struct x86_linux_header *)buf;
@@ -118,7 +121,7 @@ int do_bzImage_load(struct kexec_info *info,
 	/*
 	 * Find out about the file I am about to load.
 	 */
-	if ((uintmax_t)kernel_len < (uintmax_t)sizeof(setup_header)) {
+	if ((uintmax_t)kernel_len < (uintmax_t)(2 * 512)) {
 		return -1;
 	}
 	memcpy(&setup_header, kernel, sizeof(setup_header));
-- 
1.7.1

